% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootstrap.R
\name{bootstrap_bounds}
\alias{bootstrap_bounds}
\title{Parametric Bootstrap for Partial-Identification Bounds}
\usage{
bootstrap_bounds(
  data,
  running_var,
  outcome,
  treatment = NULL,
  cutoff,
  manip_regions,
  estimator = c("fuzzy", "sharp"),
  n_boot = 200L,
  poly_order = 1L,
  weight_var = NULL,
  density_args = list(),
  ci_level = 0.95,
  parallel = FALSE,
  n_cores = NULL,
  progress = TRUE,
  seed = NULL
)
}
\arguments{
\item{data}{A \code{data.frame} that contains the running variable, outcome and-
for fuzzy designs-the treatment column.}

\item{running_var, outcome}{Character names of the running variable and
outcome columns.}

\item{treatment}{Character name of the treatment take-up column (0/1).
Required when \code{estimator = "fuzzy"}.}

\item{cutoff}{Numeric RDD threshold.}

\item{manip_regions}{List of numeric length-2 vectors \verb{(lower, upper)} giving
suspected manipulation intervals.}

\item{estimator}{Either "fuzzy" (default) or "sharp".}

\item{n_boot}{Integer number of bootstrap replications (default \code{200}).}

\item{poly_order}{Local polynomial order (default \code{1}).}

\item{weight_var}{Optional character column in \code{data} holding non-negative
observation weights.  If \code{NULL}, each row receives weight 1.}

\item{density_args}{Optional named list forwarded to \code{.density_estimation()}.}

\item{ci_level}{Percentile coverage of the bootstrap interval (default
\code{0.95}).}

\item{parallel}{Logical.  If \code{TRUE}, uses \code{doParallel} for cross-platform
parallel execution.}

\item{n_cores}{Number of cores for parallel execution (defaults to
\code{parallel::detectCores() - 1}).}

\item{progress}{Logical - print a progress bar (default \code{TRUE}).  Progress is
suppressed automatically when running in parallel to avoid garbled output.}

\item{seed}{Optional integer for reproducibility of resampling.}
}
\value{
An object of class \code{rdpartial_boot} - a list with elements
\itemize{
\item \code{boot_array} - 3-D array \verb{(n_boot, R, 2)} storing lower/upper bounds.
\item \code{ci}         - \verb{R × 2} matrix of percentile intervals (\code{lwr}, \code{upr}).
\item \code{manip_regions}, \code{estimator}, \code{call} - metadata for downstream methods.
}
}
\description{
Draw repeated resamples of the original data \strong{keeping the running-variable
distribution fixed} and re-estimate the sharp or fuzzy RDD bounds for each
user-specified manipulation region.
}
\details{
This function is a high-level wrapper around three internal work-horses:
\itemize{
\item \code{.density_estimation()} - estimates non-manipulated counts (\code{true_counts}).
\item \code{\link[=bounds_sharp]{bounds_sharp()}} / \code{\link[=bounds_fuzzy]{bounds_fuzzy()}} - compute the Manski bounds.
\item \code{.tricube()} - constructs local-kernel weights used inside the bounds
estimators.
}
}
\examples{
set.seed(101)
n <- 3000; cutoff <- 16
x <- rpois(n, 15)
z <- rbinom(n, 1, prob = ifelse(x >= cutoff, 0.7, 0.2))
y <- 0.2 * x + 3 * z + rnorm(n)
dat <- data.frame(x = x, y = y, z = z)

res <- bootstrap_bounds(dat, running_var = "x", outcome = "y",
                        treatment = "z", cutoff = cutoff,
                        manip_regions = list(c(cutoff - 0.3, cutoff)),
                        n_boot = 50, parallel = FALSE)
res$ci

}
